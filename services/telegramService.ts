
import { PortfolioItem, Funds, Transaction } from "../types";

export const generatePNLReport = (
  portfolio: PortfolioItem[],
  currentFunds: Funds,
  initialFunds: Funds,
  marketData: any,
  period: 'DAILY' | 'WEEKLY' | 'MONTHLY' = 'DAILY'
): string => {
  const portfolioValue = portfolio.reduce((acc, item) => {
    const price = marketData[item.symbol]?.price || item.avgCost;
    return acc + (price * item.quantity);
  }, 0);

  const totalCurrentCash = currentFunds.stock;
  const totalInitial = initialFunds.stock;
  const totalEquity = totalCurrentCash + portfolioValue;
  const totalPNL = totalEquity - totalInitial;
  const pnlPercent = totalInitial > 0 ? (totalPNL / totalInitial) * 100 : 0;
  
  const now = new Date();
  const ist = new Date(now.getTime() + (now.getTimezoneOffset() * 60000) + (5.5 * 60 * 60 * 1000));
  const dateStr = ist.toLocaleDateString('en-IN', { day: '2-digit', month: 'short', year: 'numeric' });

  let header = period === 'MONTHLY' ? 'ğŸ—“ï¸ *MONTHLY PERFORMANCE REPORT*' :
               period === 'WEEKLY' ? 'ğŸ“ˆ *WEEKLY PERFORMANCE REPORT*' :
               'ğŸ“Š *DAILY PERFORMANCE REPORT*';

  let report = `${header}\nğŸ“… ${dateStr}\n\n`;
  report += `ğŸ’° *Total Portfolio Value:* â‚¹${totalEquity.toFixed(2)}\n`;
  report += `ğŸ’µ *Available Cash:* â‚¹${totalCurrentCash.toFixed(2)}\n`;
  report += `ğŸ¦ *Holdings Value:* â‚¹${portfolioValue.toFixed(2)}\n`;
  report += `ğŸ“‰ *Net ROI:* ${totalPNL >= 0 ? '+' : ''}â‚¹${totalPNL.toFixed(2)} (${pnlPercent.toFixed(2)}%)\n\n`;
  
  if (portfolio.length > 0) {
    report += `*Current Open Positions (${portfolio.length}):*\n`;
    portfolio.forEach(p => {
        const price = marketData[p.symbol]?.price || p.avgCost;
        const val = price * p.quantity;
        const itemPnl = val - p.totalCost;
        const sym = p.symbol.split('.')[0];
        const tf = p.timeframe || 'INTRA';
        report += `â€¢ ${sym} [${tf}]: ${itemPnl >= 0 ? 'ğŸŸ¢' : 'ğŸ”´'} â‚¹${itemPnl.toFixed(2)} (${((itemPnl/p.totalCost)*100).toFixed(1)}%)\n`;
    });
  } else {
    report += `_No open positions carried forward._`;
  }

  report += `\nğŸ¤– _Generated by AI Robot Engine_`;

  return report;
};

export const sendScalpAlert = async (token: string, chatId: string, tx: Transaction, pnl: number): Promise<boolean> => {
  if (!token || !chatId) return false;
  
  const isProfit = pnl >= 0;
  const message = `âš¡ *SCALP CLOSED*\n` +
                 `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
                 `ğŸ“ˆ *Asset:* ${tx.symbol.split('.')[0]}\n` +
                 `ğŸ“Š *Type:* ${tx.type}\n` +
                 `ğŸ’° *Exit Price:* â‚¹${tx.price.toFixed(2)}\n` +
                 `ğŸ’µ *Realized P&L:* ${isProfit ? 'ğŸŸ¢' : 'ğŸ”´'} *â‚¹${pnl.toFixed(2)}*\n` +
                 `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
                 `ğŸ¤– _Automated Scalper Execution_`;

  return sendTelegramMessage(token, chatId, message);
};

export const sendTelegramMessage = async (token: string, chatId: string, message: string): Promise<boolean> => {
  if (!token || !chatId) return false;
  
  try {
    const url = `https://api.telegram.org/bot${token}/sendMessage`;
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: chatId,
        text: message,
        parse_mode: 'Markdown'
      })
    });
    return response.ok;
  } catch (error) {
    console.error("Telegram send failed", error);
    return false;
  }
};
